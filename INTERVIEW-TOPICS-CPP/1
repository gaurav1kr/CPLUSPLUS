#######RAII :- 
RAII (Resource Acquisition Is Initialization) is C++ technique which control the life cycle of resource. It is a class variant and is tied to object life time.

It encapsulates several resources into class where resource allocation is done by constructor during object creation and resource deallocation is done by destructor during object destruction.
Examples are smart ponters. auto initializion.

########CODE-BLOATING
Production of code that is perceived unnecessary long ,slow and which cause unnecessary wastage of resources. 
Examples :- 
a)Functions defined inside class (By default compiler detects it online and copy the content as many times it is called)
b)Printing constants string using variable :-
string str("gaurav kumar") ; // unncessary calling string constructor 
cout<<str ;


########decltype
To check the type of expression
Example :-

#include<iostream>
using namespace std ;
template<typename T1 , typename T2>
auto add(T1 a , T2 b) -> decltype(a+b)
{
    return(a+b) ;
}

int main()
{
    float a = 2.8 ;
    int b = 2 ;
    cout<<add(a,b)<<"\n"<<add(b,a) ;
    return 0 ;
}

##########References vs Pointers
##########for vs for_each
########## lvalue , rvalue , xvalue , glvalue , prvalue :- 
            expression
                /\
               /  \
              /    \
            gval   rval
            /\      /\
           /  \    /  \
          /    \  /    \
         /      \/      \
       lval    xval     prval
— An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [ Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example, the result of calling a function whose return type is an lvalue reference is an lvalue. —end example ]

— An xvalue (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references (8.3.2). [ Example: The result of calling a function whose return type is an rvalue reference is an xvalue. —end example ]

— A glvalue (“generalized” lvalue) is an lvalue or an xvalue.

— An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment expressions) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated with an object.

— A prvalue (“pure” rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is also a prvalue.

#############static cast
1. To increase readability (C-style casting is hard to search.. by using static_cast , code readability increases)
2. Wherever conversion constructor and conversion operators are used
######## conversion constructor && conversion operator
If a class has constructor which can be called with a single argument , then it is called conversion constructor.
conversion constuctor should not be specified by 'explicit' so that compiler can use it to convert objects from the type of first parameter to type of conversion constructor's class.

Conversion operators are used to convert one concrete type to another concrete type or primitive type implicitly. It is somehow similar to operator overloading
e.g :- 

#include<iostream>
using namespace std ;
class convcons
{
    int x ;
    public:
    convcons(int v):x(v) // conversion constuctor
    {
        cout<<"Conv constructor called\n" ;
    }
    operator string() //conversion operator
    {
        cout<<"Conversion operator called\n" ;
        return (to_string(this->x)) ;
    }
};

int main()
{
   convcons cov(10) ; 
   string str1 = static_cast<string>(cov) ;
   cov = static_cast<convcons>(30) ;
   return 0 ;
}
